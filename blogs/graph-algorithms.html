<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graph Algorithms - MIT-NOTES</title>
    <link rel="stylesheet" href="../styles.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
    <header class="blog-header">
        <div class="container">
            <a href="../index.html" class="back-button">
                <i class="fas fa-arrow-left"></i>
                Back to Home
            </a>
            <h1 class="blog-title">Graph Algorithms</h1>
            <p class="blog-subtitle">Explore graph traversal and shortest path algorithms</p>
        </div>
    </header>

    <main class="main">
        <div class="container">
            <article class="blog-content">
                <!-- Title Section -->
                <section class="blog-section">
                    <h2 class="section-title">
                        <i class="fas fa-heading"></i>
                        Title
                    </h2>
                    <div class="section-content">
                        <h3>Graph Algorithms: BFS, DFS, and Shortest Path Algorithms</h3>
                        <p>Graph algorithms are fundamental to computer science and are used to solve problems involving networks, relationships, and connectivity. This comprehensive guide covers essential graph algorithms including Breadth-First Search (BFS), Depth-First Search (DFS), and shortest path algorithms like Dijkstra's.</p>
                        <p>Understanding these algorithms is crucial for solving complex problems in areas such as social networks, routing, scheduling, and optimization.</p>
                    </div>
                </section>

                <!-- Algorithm Section -->
                <section class="blog-section">
                    <h2 class="section-title">
                        <i class="fas fa-cogs"></i>
                        Algorithm
                    </h2>
                    <div class="section-content">
                        <h3>Graph Representation</h3>
                        <p>Graphs can be represented using two main methods:</p>
                        <ul>
                            <li><strong>Adjacency List:</strong> Array of lists, space efficient O(V + E)</li>
                            <li><strong>Adjacency Matrix:</strong> 2D matrix, faster edge lookup O(V²)</li>
                        </ul>

                        <h3>Breadth-First Search (BFS)</h3>
                        <p>BFS explores the graph level by level, visiting all neighbors before moving deeper.</p>
                        <ul>
                            <li>Uses a queue data structure</li>
                            <li>Finds shortest path in unweighted graphs</li>
                            <li>Time Complexity: O(V + E)</li>
                            <li>Space Complexity: O(V)</li>
                            <li>Applications: Shortest path, level order traversal, peer-to-peer networks</li>
                        </ul>

                        <h3>Depth-First Search (DFS)</h3>
                        <p>DFS explores as far as possible along each branch before backtracking.</p>
                        <ul>
                            <li>Uses a stack (explicit or recursive)</li>
                            <li>Useful for topological sorting and cycle detection</li>
                            <li>Time Complexity: O(V + E)</li>
                            <li>Space Complexity: O(V) for recursion stack</li>
                            <li>Applications: Topological sort, strongly connected components, maze solving</li>
                        </ul>

                        <h3>Dijkstra's Algorithm</h3>
                        <p>Finds shortest path from source to all vertices in weighted graph with non-negative weights.</p>
                        <ul>
                            <li>Uses a priority queue (min-heap)</li>
                            <li>Greedy algorithm approach</li>
                            <li>Time Complexity: O((V + E) log V) with priority queue</li>
                            <li>Space Complexity: O(V)</li>
                            <li>Applications: GPS navigation, network routing protocols, flight connections</li>
                        </ul>
                    </div>
                </section>

                <!-- Flowchart Section -->
                <section class="blog-section">
                    <h2 class="section-title">
                        <i class="fas fa-project-diagram"></i>
                        Flowchart
                    </h2>
                    <div class="section-content">
                        <h3>BFS Algorithm Flowchart</h3>
                        <div class="flowchart">
                            <div class="flowchart-box">Start</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Initialize Queue & Visited</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Add Start Node to Queue</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Queue Empty?</div>
                            <div class="flowchart-arrow">↓ No</div>
                            <div class="flowchart-box">Dequeue Node</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Process Node</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Add Unvisited Neighbors</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Mark as Visited</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">End</div>
                        </div>

                        <h3>DFS Algorithm Flowchart</h3>
                        <div class="flowchart">
                            <div class="flowchart-box">Start</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Initialize Stack & Visited</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Push Start Node</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Stack Empty?</div>
                            <div class="flowchart-arrow">↓ No</div>
                            <div class="flowchart-box">Pop Node</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Already Visited?</div>
                            <div class="flowchart-arrow">↓ No</div>
                            <div class="flowchart-box">Mark as Visited</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Process Node</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">Push Unvisited Neighbors</div>
                            <div class="flowchart-arrow">↓</div>
                            <div class="flowchart-box">End</div>
                        </div>
                    </div>
                </section>

                <!-- Program Section -->
                <section class="blog-section">
                    <h2 class="section-title">
                        <i class="fas fa-code"></i>
                        Program (Code)
                    </h2>
                    <div class="section-content">
                        <h3>Graph Class Implementation</h3>
                        <div class="code-block">
<span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, deque
<span class="keyword">import</span> heapq

<span class="keyword">class</span> <span class="function">Graph</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(self):
        <span class="comment"># Adjacency list representation</span>
        self.graph = defaultdict(list)
    
    <span class="keyword">def</span> <span class="function">add_edge</span>(self, u, v, weight=1):
        <span class="comment"># Add edge from u to v</span>
        self.graph[u].append((v, weight))
    
    <span class="keyword">def</span> <span class="function">add_undirected_edge</span>(self, u, v, weight=1):
        <span class="comment"># Add undirected edge</span>
        self.graph[u].append((v, weight))
        self.graph[v].append((u, weight))
    
    <span class="keyword">def</span> <span class="function">get_vertices</span>(self):
        <span class="comment"># Get all vertices in the graph</span>
        vertices = set(self.graph.keys())
        <span class="keyword">for</span> neighbors <span class="keyword">in</span> self.graph.values():
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> neighbors:
                vertices.add(neighbor)
        <span class="keyword">return</span> list(vertices)

<span class="comment"># Create sample graph</span>
g = Graph()
g.add_undirected_edge(0, 1)
g.add_undirected_edge(0, 2)
g.add_undirected_edge(1, 2)
g.add_undirected_edge(2, 3)
g.add_undirected_edge(3, 4)
                        </div>

                        <h3>Breadth-First Search Implementation</h3>
                        <div class="code-block">
<span class="keyword">def</span> <span class="function">bfs</span>(graph, start):
    <span class="comment"># Initialize visited set and queue</span>
    visited = set()
    queue = deque([start])
    result = []
    
    visited.add(start)
    
    <span class="keyword">while</span> queue:
        <span class="comment"># Dequeue a vertex</span>
        vertex = queue.popleft()
        result.append(vertex)
        
        <span class="comment"># Visit all unvisited neighbors</span>
        <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.graph[vertex]:
            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:
                visited.add(neighbor)
                queue.append(neighbor)
    
    <span class="keyword">return</span> result

<span class="keyword">def</span> <span class="function">bfs_shortest_path</span>(graph, start, end):
    <span class="comment"># Find shortest path between start and end</span>
    <span class="keyword">if</span> start == end:
        <span class="keyword">return</span> [start]
    
    visited = set([start])
    queue = deque([(start, [start])])
    
    <span class="keyword">while</span> queue:
        vertex, path = queue.popleft()
        
        <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.graph[vertex]:
            <span class="keyword">if</span> neighbor == end:
                <span class="keyword">return</span> path + [neighbor]
            
            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:
                visited.add(neighbor)
                queue.append((neighbor, path + [neighbor]))
    
    <span class="keyword">return</span> []  <span class="comment"># No path found</span>

<span class="comment"># Example usage</span>
print(<span class="string">"BFS Traversal:"</span>, bfs(g, 0))
print(<span class="string">"Shortest path from 0 to 4:"</span>, bfs_shortest_path(g, 0, 4))
                        </div>

                        <h3>Depth-First Search Implementation</h3>
                        <div class="code-block">
<span class="comment"># Recursive DFS</span>
<span class="keyword">def</span> <span class="function">dfs_recursive</span>(graph, vertex, visited, result):
    <span class="comment"># Mark current vertex as visited</span>
    visited.add(vertex)
    result.append(vertex)
    
    <span class="comment"># Visit all unvisited neighbors</span>
    <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.graph[vertex]:
        <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:
            dfs_recursive(graph, neighbor, visited, result)

<span class="keyword">def</span> <span class="function">dfs</span>(graph, start):
    visited = set()
    result = []
    dfs_recursive(graph, start, visited, result)
    <span class="keyword">return</span> result

<span class="comment"># Iterative DFS</span>
<span class="keyword">def</span> <span class="function">dfs_iterative</span>(graph, start):
    visited = set()
    stack = [start]
    result = []
    
    <span class="keyword">while</span> stack:
        vertex = stack.pop()
        
        <span class="keyword">if</span> vertex <span class="keyword">not</span> <span class="keyword">in</span> visited:
            visited.add(vertex)
            result.append(vertex)
            
            <span class="comment"># Add unvisited neighbors to stack</span>
            <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.graph[vertex]:
                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:
                    stack.append(neighbor)
    
    <span class="keyword">return</span> result

<span class="comment"># Cycle detection using DFS</span>
<span class="keyword">def</span> <span class="function">has_cycle</span>(graph):
    visited = set()
    rec_stack = set()
    
    <span class="keyword">def</span> <span class="function">dfs_cycle</span>(vertex):
        visited.add(vertex)
        rec_stack.add(vertex)
        
        <span class="keyword">for</span> neighbor, _ <span class="keyword">in</span> graph.graph[vertex]:
            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:
                <span class="keyword">if</span> dfs_cycle(neighbor):
                    <span class="keyword">return</span> True
            <span class="keyword">elif</span> neighbor <span class="keyword">in</span> rec_stack:
                <span class="keyword">return</span> True
        
        rec_stack.remove(vertex)
        <span class="keyword">return</span> False
    
    <span class="keyword">for</span> vertex <span class="keyword">in</span> graph.get_vertices():
        <span class="keyword">if</span> vertex <span class="keyword">not</span> <span class="keyword">in</span> visited:
            <span class="keyword">if</span> dfs_cycle(vertex):
                <span class="keyword">return</span> True
    
    <span class="keyword">return</span> False

<span class="comment"># Example usage</span>
print(<span class="string">"DFS Recursive:"</span>, dfs(g, 0))
print(<span class="string">"DFS Iterative:"</span>, dfs_iterative(g, 0))
print(<span class="string">"Has cycle:"</span>, has_cycle(g))
                        </div>

                        <h3>Dijkstra's Shortest Path Algorithm</h3>
                        <div class="code-block">
<span class="keyword">def</span> <span class="function">dijkstra</span>(graph, start):
    <span class="comment"># Initialize distances and previous vertices</span>
    vertices = graph.get_vertices()
    distances = {vertex: float(<span class="string">'inf'</span>) <span class="keyword">for</span> vertex <span class="keyword">in</span> vertices}
    previous = {vertex: <span class="keyword">None</span> <span class="keyword">for</span> vertex <span class="keyword">in</span> vertices}
    distances[start] = 0
    
    <span class="comment"># Priority queue: (distance, vertex)</span>
    pq = [(0, start)]
    visited = set()
    
    <span class="keyword">while</span> pq:
        current_dist, current = heapq.heappop(pq)
        
        <span class="keyword">if</span> current <span class="keyword">in</span> visited:
            <span class="keyword">continue</span>
        
        visited.add(current)
        
        <span class="comment"># Check all neighbors</span>
        <span class="keyword">for</span> neighbor, weight <span class="keyword">in</span> graph.graph[current]:
            distance = current_dist + weight
            
            <span class="comment"># If shorter path found</span>
            <span class="keyword">if</span> distance < distances[neighbor]:
                distances[neighbor] = distance
                previous[neighbor] = current
                heapq.heappush(pq, (distance, neighbor))
    
    <span class="keyword">return</span> distances, previous

<span class="keyword">def</span> <span class="function">reconstruct_path</span>(previous, start, end):
    <span class="comment"># Reconstruct shortest path</span>
    path = []
    current = end
    
    <span class="keyword">while</span> current <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:
        path.append(current)
        current = previous[current]
    
    path.reverse()
    
    <span class="keyword">if</span> path[0] == start:
        <span class="keyword">return</span> path
    <span class="keyword">else</span>:
        <span class="keyword">return</span> []  <span class="comment"># No path exists</span>

<span class="comment"># Create weighted graph for Dijkstra</span>
wg = Graph()
wg.add_edge(0, 1, 4)
wg.add_edge(0, 2, 1)
wg.add_edge(2, 1, 2)
wg.add_edge(1, 3, 1)
wg.add_edge(2, 3, 5)
wg.add_edge(3, 4, 3)

<span class="comment"># Find shortest paths</span>
distances, previous = dijkstra(wg, 0)
print(<span class="string">"Shortest distances from vertex 0:"</span>, distances)

<span class="comment"># Find shortest path from 0 to 4</span>
path = reconstruct_path(previous, 0, 4)
print(<span class="string">f"Shortest path from 0 to 4: {path}"</span>)
print(<span class="string">f"Distance: {distances[4]}"</span>)
                        </div>
                    </div>
                </section>
            </article>
        </div>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2025 MIT-NOTES. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>